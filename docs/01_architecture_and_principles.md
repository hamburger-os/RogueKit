[&#8617; 返回总览](../README.md)

---

## 1. 基础架构与核心原则

本章节将建立指导整个 **RogueKit** 开发的架构准则与设计模式。这些原则是确保库的一致性、可维护性和可扩展性的基石。

### 1.1. “The Godot Way”：组合优于继承

在Godot的设计哲学中，节点（Node）和场景（Scene）的树状结构天然地鼓励使用组合模式。一个独立的场景可以作为另一个场景中的一个节点实例，这使得我们可以将复杂的对象由一系列更小、可复用的部分组装而成。这种设计理念能够有效规避深度且僵化的继承体系所带来的弊端。随着项目规模的扩大，复杂的继承关系会变得难以重构和维护，这种现象被称为“固化”。

**RogueKit** 将严格遵循“组合优于继承”的原则。这意味着游戏中的实体（Entity），如玩家或敌人，将不会通过深层的类继承（例如，`Goblin` 继承 `MeleeEnemy` 继承 `BaseEnemy`）来定义。这样做会极大地限制灵活性，例如，当需要创建一个不符合预设结构的全新实体（如一个固定的、会施法的魔法图腾）时，继承体系会显得力不从心。

取而代之，我们将实体定义为基础场景，其具体行为和能力通过附加子节点（即“组件”）来实现。这种方式充分利用了Godot引擎内置的、类似于原型模式（Prototype Pattern）的强大功能。例如，一个哥布林实体可能由一个`CharacterBody2D`根节点，以及作为其子节点的`HealthComponent`（生命组件）、`AIMovementComponent`（AI移动组件）和`MeleeAttackComponent`（近战攻击组件）等场景构成。这种架构选择是实现 **RogueKit** 核心目标——支持快速开发多样化Roguelike游戏——的先决条件。它将实体创建过程从复杂的编码任务转变为在编辑器中进行的可视化“组装”工作，从而赋予开发者最大的创作自由度。

### 1.2. 数据驱动指令：充分利用Godot资源

**RogueKit** 的第二个核心原则是严格的数据驱动设计，其实现将深度依赖Godot的`Resource`系统。`Resource`是为承载数据而生的理想容器，它们可以被多个节点共享、序列化保存，并作为独立的资产在编辑器中进行管理和配置。在实践中，使用`Resource`来定义游戏数据（如角色属性、物品、掉落表等）是一种被广泛验证的高效模式。

我们将强制推行数据与逻辑的分离。节点的脚本（如`HealthComponent.gd`）定义了“行为”——它知道如何管理生命值、承受伤害。而`Resource`文件（如`GoblinData.tres`）则定义了“是什么”——它具体指明了一个哥布林拥有20点最大生命值。这种模式实际上是享元模式（Flyweight Pattern）的一种体现，通过共享不变的数据来最小化内存占用。

全面采用基于`Resource`的数据模型，意味着 **RogueKit** 不仅提供代码，更重要的是，它为最终用户定义了一套完整的“内容创作管线”。对于使用 **RogueKit** 的游戏设计师或开发者而言，添加一个新的怪物、一件新装备或一个新技能，其主要工作流程将是在Godot编辑器中创建并配置相应的`.tres`资源文件，而非编写新的逻辑代码。这极大地降低了内容创作的技术门槛，使得团队中的非程序员也能高效地参与到游戏内容的构建中。同时，这种方式也使得游戏内容高度模块化、易于通过版本控制系统进行管理，并为未来的内容扩展提供了坚实的基础。因此，本设计文档不仅会阐述代码架构，也会详细定义这些核心`Resource`的数据结构，因为它们是开发者与 **RogueKit** 交互的主要界面。

### 1.3. 通信模式：一种用于解耦的混合方法

在复杂的系统中，各个模块间的通信方式是决定代码可维护性的关键。Godot引擎通过信号（Signal）系统提供了其原生实现的观察者模式（Observer Pattern），这是实现代码解耦的重要工具。然而，当通信发生在场景树中相距甚远的节点之间时，通过逐级向上传递信号（即“信号冒泡”）的方式会变得非常繁琐且难以追踪。在这种情况下，使用一个全局事件总线（通常实现为一个自动加载的单例 Autoload Singleton）是一种推荐的替代方案。

然而，过度依赖全局事件总线也存在风险，它可能导致一种新的“意大利面条式代码”，使得事件的来源和监听者难以追溯，从而增加调试的复杂性。因此，**RogueKit** 将不采用单一的通信方式，而是建立一套清晰的、分层级的混合通信协议，以规范不同场景下的模块交互。

选择直接函数调用、节点信号还是全局事件总线，不应是随意的，而应基于通信双方的耦合关系和通信需求。通过制定明确的协议，可以防止项目在迭代过程中出现架构腐化。

* **第一层级（内部/高耦合）：直接函数调用**
    * **场景**：父节点对其直接子组件进行命令式的控制。例如，玩家节点调用其子节点`HealthComponent`的`take_damage`方法。
    * **理由**：这是最高效、最直接的通信方式。由于父节点和其组件在逻辑上是紧密耦合的整体，直接调用是完全合理的。

* **第二层级（局部/中耦合）：节点信号**
    * **场景**：一个组件需要通知其所有者（父节点）或兄弟节点某个状态发生了变化，但它不应该知道也不关心谁会对此做出反应。例如，`HealthComponent`在生命值耗尽时发出`health_depleted`信号，其父节点（如`Player`或`Enemy`）连接此信号以执行死亡逻辑。
    * **理由**：这完美地体现了“信号向上，调用向下”的设计思想。它允许组件保持独立和可复用，同时有效地将事件通知给关心它的上层逻辑。

* **第三层级（全局/低耦合）：全局事件总线**
    * **场景**：一个系统需要广播一个重要的、全局性的游戏事件，多个完全不相关的系统可能都需要对此事件做出响应。例如，“玩家升级”（`player_leveled_up`）事件可能会被UI系统、音效系统和成就系统同时监听。
    * **理由**：事件总线（`Events.gd` Autoload）在此处是理想选择。它允许事件的发布者和订阅者之间完全解耦，任何系统都可以监听这些全局事件，而无需与事件的来源有任何直接联系。

为了将这一协议固化为开发者易于遵循的实践指南，特提供下表作为参考：

**表1：通信模式选择指南**

| 模式 | 适用场景 | 耦合级别 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- | :--- |
| **直接函数调用** | 父节点对子组件的直接命令 | 高 | 性能最高，意图明确，易于代码追踪 | 增加了节点间的紧密依赖关系 |
| **节点信号** | 组件向其所有者或未知监听者通知状态变化 | 中 | 实现了发布者与订阅者的解耦，符合Godot设计哲学 | 对于跨越多个层级的远距离通信，需要“信号冒泡”，变得复杂 |
| **全局事件总线** | 广播全局性事件，供多个不相关系统监听 | 低 | 完全解耦，简化了远距离和一对多通信 | 滥用会导致事件流难以追踪，增加调试难度，可能隐藏依赖关系 |

### 1.4. 框架结构：项目组织与GDScript标准

一个清晰、一致的项目结构和编码规范是保证大型项目可维护性的基础。**RogueKit** 将遵循业界和社区的最佳实践。

作为一个旨在通过 Git Submodule 集成的库，本项目遵循扁平化的结构。所有代码和资源都直接位于根目录中，并按功能模块进行组织，而非按文件类型。例如，所有与世界生成相关的逻辑和资源将位于`world_gen/`目录下，所有与实体相关的则位于`entity/`目录下。这种“按功能聚合”的结构有助于保持模块的内聚性，并减少在不同目录间跳转的频率。

所有GDScript代码将严格遵守Godot社区（特别是GDQuest）推荐的编码风格指南。这包括但不限于：
* **代码顺序**：严格遵循`class_name`、`extends`、信号、枚举、常量、导出变量、公共变量、私有变量、内置回调函数、公共方法、私有方法的顺序。
* **命名约定**：在Godot 4中，类名（`class_name`）和枚举类型名使用帕斯卡命名法（PascalCase），而文件、函数、变量和信号名使用蛇形命名法（snake_case）。
* **静态类型**：所有变量、函数参数和返回值都将使用静态类型提示。尽管在当前版本的GDScript中，静态类型对性能的提升有限，但它极大地增强了代码的可读性、提供了更好的自动补全支持，并能在编码阶段捕获大量潜在的类型错误。