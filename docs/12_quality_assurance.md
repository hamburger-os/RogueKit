[&#8617; 返回总览](../README.md)

---

## 12. 质量保障：测试策略与调试工具

为了确保库的质量和稳定性，并为开发者提供便利，**RogueKit**将包含周密的测试策略和内置的调试工具。

### 12.1. 功能测试策略

#### 12.1.1. 测试层级

* **单元测试 (Unit Tests)**: 针对没有场景依赖的核心逻辑和数据处理部分（例如`LootTable`的权重计算、`Stat`的修改器应用逻辑）。我们将使用Godot单元测试框架（如GUT）编写单元测试。这有助于在开发早期捕捉逻辑错误，并确保算法的正确性。
* **集成测试 (Integration Tests)**: 针对需要多个组件协同工作的场景（例如，一个完整的实体受到伤害并触发死亡信号）。将编写集成测试脚本来验证其端到端的功能，确保组件间的契约（API和信号）按预期工作。

#### 12.1.2. 自动化测试与依赖注入

为了实现可靠的、可在无头（headless）模式下自动运行的测试，**RogueKit** 采用**依赖注入（Dependency Injection）**模式来处理全局管理器（如`GameManager`）和事件总线（`Events`）。

*   **原则**: 核心游戏逻辑（如组件`Component`和动作`Action`）**不应**直接调用全局单例（例如，`GameManager.get_player()`）。
*   **实践**:
    *   需要访问全局状态的节点，应提供一个可设置的公共属性（例如 `var game_manager: Node`）。
    *   在测试场景的根脚本中，负责手动实例化这些管理器，并通过设置属性的方式将它们的引用“注入”到需要它们的节点中。
*   **优势**: 这种方法避免了在Godot的无头测试模式下自动加载（Autoload）不可靠的问题，并显著降低了代码模块间的耦合度，使单元测试和集成测试的编写变得更加简单和健壮。

#### 12.1.3. 验收标准示例 (Acceptance Criteria Example)

所有功能的“完成”状态都必须通过明确的验收标准来衡量。我们将采用**Given-When-Then**格式来定义测试用例：

* **示例1：LootTable 权重测试 (单元测试)**
    * **Given**：一个`LootTable`资源，包含两个条目：物品A（权重=80）和物品B（权重=20）。
    * **When**：调用`roll_loot()`方法10,000次。
    * **Then**：物品A的掉落次数应在7800到8200之间（允许2%的容错率），物品B的掉落次数应在1800到2200之间。

* **示例2：HealthComponent 伤害处理 (集成测试)**
    * **Given**：一个实体场景，其`HealthComponent`的`max_health`初始化为100，当前`health`为100。
    * **When**：调用实体的`take_damage(25)`方法。
    * **Then**：实体的`HealthComponent.health`属性应更新为75，并且`health_changed`信号必须被触发一次，其参数为（旧值=100, 新值=75）。

### 12.2. 性能基准测试 (Performance Benchmarking)

为了确保库能够在目标规模下流畅运行，我们将制定并执行性能基准测试。

* **核心指标**:
    * **帧率 (FPS)**: 游戏运行的平滑度。
    * **逻辑帧时间 (Process Frame Time)**: 游戏逻辑计算所消耗的时间，用于识别CPU瓶颈。
    * **内存占用 (Memory Usage)**: 跟踪对象池和资源加载对内存的影响。
* **基准测试场景**:
    * **场景1：地图生成压力测试**: 生成不同尺寸（例如 50x50, 100x100, 200x200）的地图，记录生成所需时间。目标：100x100地图生成时间应小于500毫秒。
    * **场景2：AI实体规模测试**: 在100x100的地图上，分别放置20、50、100个活动AI实体。目标：在100个AI实体活动时，逻辑帧时间不应超过8毫秒（保证60FPS下的稳定裕量）。
* **工具**: 主要使用Godot内置的性能分析器（Profiler）和监视器（Monitors）进行数据收集。

### 12.3. 内置调试工具

为了帮助开发者诊断问题，**RogueKit**将提供一些可选的调试工具：

* **调试覆盖层 (Debug Overlay)**: 一个可以在游戏运行时切换的UI层，用于实时显示关键信息，如玩家坐标、当前游戏状态、AI正在执行的行为树节点等。
* **可视化调试**: 提供在游戏世界中绘制调试信息的功能。例如，可以开启一个选项来可视化显示AI的寻路路径、敌人的视野范围或`MapData`的逻辑网格。
* **开发者控制台**: 一个简单的游戏内控制台，允许开发者输入命令来执行特定操作，如生成物品、传送到特定位置或切换无敌模式。