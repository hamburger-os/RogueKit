[&#8617; 返回总览](../README.md)

---

## 2. 世界生成子系统

该子系统负责程序化地创建游戏关卡。其设计的核心目标是模块化和可配置性，允许开发者通过数据组合轻松地定义、混合和定制关卡生成算法。

### 2.1. `MapGenerator` 协调器

程序化内容生成（PCG）通常是一个多阶段的复杂过程。例如，一个典型的地牢生成流程可能包括：首先放置预设的房间或障碍物，然后运行一个隧道算法连接它们，接着移除死胡同，平滑墙壁，最后再在生成的地图上填充敌人和物品。

为了管理这一流程，我们将设计一个中心的`MapGenerator`节点。该节点本身不包含任何具体的生成算法逻辑，其核心职责是作为一个协调器。它将接收一个`MapGenerationProfile`类型的`Resource`作为输入，该资源定义了生成所需的所有步骤和参数。`MapGenerator`会按照该配置文件中定义的顺序，依次执行一系列“生成通道”（Generation Pass），并最终输出一个抽象的`MapData`对象，该对象完整地描述了生成关卡的逻辑结构。

### 2.2. 策略模式：实现模块化生成算法

Roguelike游戏中的地图生成算法多种多样，常见的包括用于生成自然洞穴的元胞自动机（Cellular Automata），用于构建结构化地牢的二叉空间分割树（BSP Tree），以及用于挖掘隧道的醉汉行走算法（Drunkard's Walk）。更高级的生成器往往会将这些算法组合使用，以创造出更丰富多变的关卡。

为了支持这种算法的多样性和可组合性，我们将采用策略（Strategy）设计模式。具体实现如下：
1.  定义一个基础的`GenerationPass` `Resource`类，它包含一个必须被子类实现的`generate(map_data)`方法。
2.  为每种具体的生成算法创建继承自`GenerationPass`的`Resource`脚本，例如`CellularAutomataPass.gd`、`BSPTreePass.gd`和`CorridorPass.gd`。每个脚本将实现其独特的生成逻辑。
3.  这些具体的`GenerationPass`资源将使用`@export`关键字暴露出其特有的配置参数，如元胞自动机的迭代次数`iterations`或BSP树的最小房间尺寸`min_room_size`。

通过这种设计，整个关卡生成流程被转化为了一个纯粹的数据配置任务。开发者无需编写任何新的生成代码，只需在Godot编辑器中创建一个新的`MapGenerationProfile`资源，然后像搭积木一样，将预设的`GenerationPass`资源拖拽到其数组中，并调整每个通道的导出参数。这种方式极大地增强了库的灵活性和易用性，完美地践行了数据驱动的核心设计理念。

为了帮助开发者更好地选择和组合这些算法，提供以下参考表格：

**表2：地图生成算法比较**

| 算法 | 最佳适用场景 | 关键可配置参数 | 性能说明 |
| :--- | :--- | :--- | :--- |
| **元胞自动机** | 自然、不规则的洞穴系统 | `iterations` (迭代次数), `neighbors` (邻居阈值), `ground_chance` (初始地面概率) | 性能消耗与迭代次数和地图大小成正比，适合离线生成。 |
| **BSP树** | 结构化、由房间和走廊构成的地牢 | `min_room_size` (最小房间尺寸), `min_room_factor` (房间尺寸比例) | 生成速度快，结构清晰，易于控制房间布局。 |
| **醉汉行走** | 随机、蜿蜒的隧道或洞穴网络 | `walk_steps` (行走步数), `digger_count` (挖掘者数量) | 简单高效，结果随机性强，适合创建连接通道或小型洞穴。 |
| **房间放置与连接** | 预设房间布局，保证连通性 | `room_count` (房间数量), `room_size_range` (房间尺寸范围) | 算法直接，结果可控，常用于经典Roguelike地牢。 |

### 2.3. 抽象地图：`MapData` vs. `TileMap`

在架构设计中，将数据的逻辑表示与其视觉表示分离是一种重要的最佳实践。对于地图生成而言，`TileMap`节点主要负责图形渲染，而不应承载核心的地图数据和逻辑。生成过程应该首先在一个更简单、更抽象的数据结构上进行操作。

因此，`MapGenerator`的输出将不是一个配置好的`TileMap`节点，而是一个自定义的`MapData` `Resource`对象。这个`MapData`对象是地图的纯数据抽象，它将包含：
* 一个二维数组，用于表示地图网格的基本布局（例如，`TileType.WALL`或`TileType.FLOOR`）。
* 一个房间列表，包含每个已识别房间的位置、大小等信息。
* 走廊路径的集合。
* 潜在的实体生成点、楼梯位置等特殊标记。

生成流程完成后，一个独立的`MapBuilder`节点将负责“翻译”这个`MapData`对象。它会读取`MapData`中的信息，并根据预设的`TileSet`将其渲染到实际的`TileMap`或`GridMap`节点上。

这种分离带来了多重战略优势。首先，它提升了性能和效率。寻路算法（如A*）在简单的二维数组上运行，远比在复杂的`TileMap`节点上进行查询要快得多。其次，它实现了系统的解耦。地图生成算法无需关心具体的瓦片ID、图集坐标或渲染层级，只需处理`WALL`和`FLOOR`这样的抽象概念。最后，也是至关重要的一点，它极大地增强了系统的可测试性。我们可以编写一个“无头”（headless）的测试脚本，运行`MapGenerator`并直接验证输出的`MapData`对象的正确性，而无需实例化任何场景或启动图形界面。这对于实现自动化测试和持续集成（CI/CD）流程至关重要。

### 2.4. 世界填充与种子

地图的几何结构生成后，还需要用敌人、物品、陷阱等游戏元素来填充它。为了保证游戏的可重复性和可调试性，整个生成过程（包括结构生成和内容填充）都应该是确定性的，即对于同一个种子（Seed），每次都应产生完全相同的结果。

`MapGenerator`在完成结构生成后，将继续负责世界的填充阶段。它会利用`MapData`中提供的信息（如房间列表）来确定有效的放置位置。填充的内容和逻辑同样是数据驱动的，它会使用`SpawnProfile`资源（详见5.2节）来决定“放置什么”以及放置的规则（如每个房间的怪物密度）。一个初始的种子值将被传递给一个`RandomNumberGenerator`实例，该实例将在整个生成和填充过程的所有随机决策中使用，以确保结果的确定性。